"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const discord_js_1 = require("discord.js");
const BaseStrings_1 = require("../../localization/BaseStrings");
const Lang_1 = require("../../localization/Lang");
const Util_1 = require("../../util/Util");
const Time_1 = require("../../util/Time");
function resolve(argTypes) {
    if (typeof argTypes === 'string')
        argTypes =
            Util_1.Util.parseArgTypes(argTypes);
    const idRegex = /^(?:<@!?)?(\d+)>?$/;
    const normalizeUser = text => text.toLowerCase().replace(/[^a-z0-9#]+/g, '');
    const names = Object.keys(argTypes);
    const types = names
        .map(name => argTypes[name]);
    return async function (message, args) {
        const dm = message.channel.type !== 'text';
        const lang = dm
            ? this.client.defaultLang
            : await message.guild.storage.settings.get('lang')
                || this.client.defaultLang;
        const res = Lang_1.Lang.createResourceLoader(lang);
        const prefix = !dm ? await message.guild.storage.settings.get('prefix') : '';
        const usage = Lang_1.Lang.getCommandInfo(this, lang).usage.replace('<prefix>', prefix);
        let foundRestArg = false;
        for (let [index, arg] of args.entries()) {
            if (index > names.length - 1)
                break;
            const name = names[index];
            const type = types[index];
            if (name.includes('...')) {
                if (index !== names.length - 1)
                    throw new Error(`Rest arg \`${name}\` must be the final argument descriptor.`);
                arg = args.slice(index).join(' ');
                args[index] = arg;
                args = args.slice(0, index + 1);
                foundRestArg = true;
            }
            if (dm && !['String', 'Number', 'Duration', 'User'].includes(type))
                throw new Error(`in arg \`${name}\`: Type \`${type}\` is not usable within DM-capable commands.`);
            if (type === 'String') {
                args[index] = arg.toString();
            }
            else if (type === 'Number') {
                if (isNaN(arg))
                    throw new Error(res(BaseStrings_1.BaseStrings.RESOLVE_ERR_RESOLVE_NUMBER, { name, arg, usage }));
                args[index] = parseFloat(arg);
            }
            else if (type === 'Duration') {
                let duration = Time_1.Time.parseShorthand(arg);
                if (!duration)
                    throw new Error(res(BaseStrings_1.BaseStrings.RESOLVE_ERR_RESOLVE_DURATION, { name, arg, usage }));
                args[index] = duration;
            }
            else if (type === 'User') {
                let user;
                if (idRegex.test(arg)) {
                    try {
                        user = await message.client.fetchUser(arg.match(idRegex)[1]);
                    }
                    catch (err) { }
                    if (!user)
                        throw new Error(res(BaseStrings_1.BaseStrings.RESOLVE_ERR_RESOLVE_TYPE_ID, { name, arg, usage, type }));
                }
                else {
                    const normalized = normalizeUser(arg);
                    let users = this.client.users.filter(a => normalizeUser(a.username).includes(normalized) || normalizeUser(a.tag).includes(normalized));
                    if (message.channel.type === 'text')
                        users = users.concat(new discord_js_1.Collection(message.guild.members
                            .filter(a => normalizeUser(a.displayName).includes(normalized))
                            .map(a => [a.id, a.user])));
                    if (users.size > 1)
                        throw String(res(BaseStrings_1.BaseStrings.RESOLVE_ERR_MULTIPLE_USER_RESULTS, { name, usage, users: users.map(u => `\`${u.tag}\``).join(', ') }));
                    user = users.first();
                    if (!user)
                        throw new Error(res(BaseStrings_1.BaseStrings.RESOLVE_ERR_RESOLVE_TYPE_TEXT, { name, arg, usage, type }));
                }
                args[index] = user;
            }
            else if (type === 'Member') {
                let member;
                if (idRegex.test(arg)) {
                    try {
                        member = await message.guild.fetchMember(arg.match(idRegex)[1]);
                    }
                    catch (err) { }
                    if (!member)
                        throw new Error(res(BaseStrings_1.BaseStrings.RESOLVE_ERR_RESOLVE_TYPE_ID, { name, arg, usage, type }));
                }
                else {
                    const normalized = normalizeUser(arg);
                    let members = message.guild.members
                        .filter(a => normalizeUser(a.displayName).includes(normalized)
                        || normalizeUser(a.user.username).includes(normalized)
                        || normalizeUser(a.user.tag).includes(normalized));
                    if (members.size > 1)
                        throw String(res(BaseStrings_1.BaseStrings.RESOLVE_ERR_MULTIPLE_USER_RESULTS, { name, usage, users: members.map(m => `\`${m.user.tag}\``).join(', ') }));
                    member = members.first();
                    if (!member)
                        throw new Error(res(BaseStrings_1.BaseStrings.RESOLVE_ERR_RESOLVE_TYPE_TEXT, { name, arg, usage, type }));
                }
                args[index] = member;
            }
            else if (type === 'BannedUser') {
                const bannedUsers = await message.guild.fetchBans();
                let user;
                if (idRegex.test(arg)) {
                    user = bannedUsers.get(arg.match(idRegex)[1]);
                    if (!user)
                        throw new Error(res(BaseStrings_1.BaseStrings.RESOLVE_ERR_RESOLVE_TYPE_ID, { name, arg, usage, type }));
                }
                else {
                    const normalized = normalizeUser(arg);
                    let users = bannedUsers.filter(a => normalizeUser(a.username).includes(normalized)
                        || normalizeUser(a.tag).includes(normalized));
                    if (users.size > 1)
                        throw String(res(BaseStrings_1.BaseStrings.RESOLVE_ERR_MULTIPLE_USER_RESULTS, { name, usage, users: users.map(u => `\`${u.tag}\``).join(', ') }));
                    user = users.first();
                    if (!user)
                        throw new Error(res(BaseStrings_1.BaseStrings.RESOLVE_ERR_RESOLVE_TYPE_TEXT, { name, arg, usage, type }));
                }
                args[index] = user;
            }
            else if (type === 'Channel') {
                let channel;
                const channelRegex = /^(?:<#)?(\d+)>?$/;
                if (channelRegex.test(arg)) {
                    const id = arg.match(channelRegex)[1];
                    channel = message.guild.channels.get(id);
                    if (!channel)
                        throw new Error(res(BaseStrings_1.BaseStrings.RESOLVE_ERR_RESOLVE_TYPE_ID, { name, arg, usage, type }));
                }
                else {
                    const normalized = Util_1.Util.normalize(arg);
                    let channels = message.guild.channels
                        .filter(a => a.type === 'text')
                        .filter(a => Util_1.Util.normalize(a.name).includes(normalized));
                    if (channels.size > 1)
                        throw String(res(BaseStrings_1.BaseStrings.RESOLVE_ERR_MULTIPLE_CHANNEL_RESULTS, { name, usage, channels: channels.map(c => `\`#${c.name}\``).join(', ') }));
                    channel = channels.first();
                    if (!channel)
                        throw new Error(res(BaseStrings_1.BaseStrings.RESOLVE_ERR_RESOLVE_TYPE_TEXT, { name, arg, usage, type }));
                }
                args[index] = channel;
            }
            else if (type === 'Role') {
                let role;
                const roleRegex = /^(?:<@&)?(\d+)>?$/;
                if (roleRegex.test(arg)) {
                    const id = arg.match(roleRegex)[1];
                    role = message.guild.roles.get(id);
                    if (!role)
                        throw new Error(res(BaseStrings_1.BaseStrings.RESOLVE_ERR_RESOLVE_TYPE_ID, { name, arg, usage, type }));
                }
                else {
                    const normalized = Util_1.Util.normalize(arg);
                    let roles = message.guild.roles.filter(a => Util_1.Util.normalize(a.name).includes(normalized));
                    if (roles.size > 1)
                        throw String(res(BaseStrings_1.BaseStrings.RESOLVE_ERR_MULTIPLE_ROLE_RESULTS, { name, usage, roles: roles.map(r => `\`${r.name}\``).join(', ') }));
                    role = roles.first();
                    if (!role)
                        throw new Error(res(BaseStrings_1.BaseStrings.RESOLVE_ERR_RESOLVE_TYPE_TEXT, { name, arg, usage, type }));
                }
                args[index] = role;
            }
            else {
                throw new Error(`in arg \`${name}\`: Type \`${type}\` is not a valid argument type.`);
            }
            if (foundRestArg)
                break;
        }
        return [message, args];
    };
}
exports.resolve = resolve;

//# sourceMappingURL=Resolve.js.map
