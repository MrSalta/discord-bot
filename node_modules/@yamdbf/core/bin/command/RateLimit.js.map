{"version":3,"sources":["command/RateLimit.ts"],"names":[],"mappings":";;AAAA;;;;;GAKG;AACH;IAOC,YAAmB,KAAuB;QAEzC,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,GAAG,KAAK,CAAC;QACtC,IAAI,CAAC,MAAM,EAAE,CAAC;IACf,CAAC;IAED;;;OAGG;IACK,MAAM;QAEb,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;QAChB,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;QACjB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;IACxB,CAAC;IAED;;;;;OAKG;IACI,IAAI;QAEV,IAAI,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE;YAAE,IAAI,CAAC,MAAM,EAAE,CAAC;QAC7C,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM;YAAE,OAAO,KAAK,CAAC;QAC7C,IAAI,CAAC,MAAM,EAAE,CAAC;QACd,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC;YAAE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC;QAClE,OAAO,IAAI,CAAC;IACb,CAAC;IAED;;;OAGG;IACH,IAAW,SAAS;QAEnB,OAAO,CAAC,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC;IACpE,CAAC;IAED;;;;OAIG;IACI,WAAW;QAEjB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;IACvB,CAAC;IAED;;;;OAIG;IACH,IAAW,WAAW;QAErB,OAAO,IAAI,CAAC,SAAS,CAAC;IACvB,CAAC;CACD;AAnED,8BAmEC","file":"RateLimit.js","sourcesContent":["/**\n * Maintains its own call count and expiry for making sure\n * things only happen a certain number of times within\n * a given timeframe\n * @param {Tuple<number, number>} limit Tuple containing quantity and duration\n */\nexport class RateLimit\n{\n\tprivate readonly _limit: number;\n\tprivate readonly _duration: number;\n\tprivate _count: number;\n\tprivate _notified: boolean;\n\tpublic expires: number;\n\tpublic constructor(limit: [number, number])\n\t{\n\t\t[this._limit, this._duration] = limit;\n\t\tthis._reset();\n\t}\n\n\t/**\n\t * Sets this RateLimit to default values\n\t * @private\n\t */\n\tprivate _reset(): void\n\t{\n\t\tthis._count = 0;\n\t\tthis.expires = 0;\n\t\tthis._notified = false;\n\t}\n\n\t/**\n\t * Returns whether or not this rate limit has been capped out\n\t * for its current expiry window while incrementing calls\n\t * towards the rate limit cap if not currently capped\n\t * @returns {boolean}\n\t */\n\tpublic call(): boolean\n\t{\n\t\tif (this.expires < Date.now()) this._reset();\n\t\tif (this._count >= this._limit) return false;\n\t\tthis._count++;\n\t\tif (this._count === 1) this.expires = Date.now() + this._duration;\n\t\treturn true;\n\t}\n\n\t/**\n\t * Return whether or not this ratelimit is currently capped out\n\t * @returns {boolean}\n\t */\n\tpublic get isLimited(): boolean\n\t{\n\t\treturn (this._count >= this._limit) && (Date.now() < this.expires);\n\t}\n\n\t/**\n\t * Flag this RateLimit as having had the user the RateLimit\n\t * is for notified of being rate limited\n\t * @returns {void}\n\t */\n\tpublic setNotified(): void\n\t{\n\t\tthis._notified = true;\n\t}\n\n\t/**\n\t * Return whether or not this RateLimit was flagged after\n\t * notifying the user of being rate limited\n\t * @returns {boolean}\n\t */\n\tpublic get wasNotified(): boolean\n\t{\n\t\treturn this._notified;\n\t}\n}\n"],"sourceRoot":"../../src"}