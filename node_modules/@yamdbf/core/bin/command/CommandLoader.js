"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const glob = require("glob");
const path = require("path");
const Logger_1 = require("../util/logger/Logger");
/**
 * Handles loading all commands from the given Client's commandsDir
 * @private
 */
class CommandLoader {
    constructor(client) {
        this._client = client;
    }
    /**
     * Load or reload all commands from the base commands directory and the
     * user-specified {@link Client#commandsDir} directory and stores them in
     * the Client's {@link CommandRegistry} instance ({@link Client#commands})
     */
    loadCommands() {
        if (this._client.commands.size > 0)
            for (const cmd of this._client.commands.filter(c => !c.external).values())
                this._client.commands.delete(cmd.name);
        let commandFiles = [];
        commandFiles.push(...glob.sync(`${path.join(__dirname, './base')}/**/*.js`));
        if (this._client.commandsDir)
            commandFiles.push(...glob.sync(`${this._client.commandsDir}/**/*.js`));
        let loadedCommands = 0;
        for (const fileName of commandFiles) {
            const commandLocation = fileName.replace('.js', '');
            delete require.cache[require.resolve(commandLocation)];
            const loadedCommandClass = this.getCommandClass(commandLocation);
            const command = new loadedCommandClass();
            if (this._client.disableBase.includes(command.name))
                continue;
            command._classloc = commandLocation;
            if (this._client.commands.find(c => c.overloads === command.name)) {
                this.logger.info('CommandLoader', `Skipping exterally overloaded command: '${command.name}'`);
                continue;
            }
            if (command.overloads) {
                if (!this._client.commands.has(command.overloads))
                    throw new Error(`Command "${command.overloads}" does not exist to be overloaded.`);
                this._client.commands.delete(command.overloads);
                this._client.commands._registerInternal(command);
                this.logger.info('CommandLoader', `Command '${command.name}' loaded, overloading command '${command.overloads}'.`);
            }
            else {
                this._client.commands._registerInternal(command);
                loadedCommands++;
                this.logger.info('CommandLoader', `Command '${command.name}' loaded.`);
            }
        }
        this.logger.info('CommandLoader', `Loaded ${loadedCommands} total commands in ${this._client.commands.groups.length} groups.`);
    }
    /**
     * Reload the given command in the Client's {@link CommandRegistry} ({@link Client#commands})
     */
    reloadCommand(nameOrAlias) {
        const name = this._client.commands.findByNameOrAlias(nameOrAlias).name;
        if (!name)
            return;
        if (this._client.commands.get(name).external)
            return;
        const commandLocation = this._client.commands.get(name)._classloc;
        delete require.cache[require.resolve(commandLocation)];
        const loadedCommandClass = this.getCommandClass(commandLocation);
        const command = new loadedCommandClass();
        command._classloc = commandLocation;
        this._client.commands._registerInternal(command, true);
        this.logger.info('CommandLoader', `Command '${command.name}' reloaded.`);
    }
    /**
     * Get the Command class from an attempted Command class import
     */
    getCommandClass(loc) {
        const importedObj = require(loc);
        let commandClass;
        if (importedObj && Object.getPrototypeOf(importedObj).name !== 'Command') {
            for (const key of Object.keys(importedObj))
                if (Object.getPrototypeOf(importedObj[key]).name === 'Command') {
                    commandClass = importedObj[key];
                    break;
                }
        }
        else
            commandClass = importedObj;
        if (!commandClass || Object.getPrototypeOf(commandClass).name !== 'Command')
            throw new Error(`Failed to find an exported Command class in file '${loc}'`);
        return commandClass;
    }
}
__decorate([
    Logger_1.logger
], CommandLoader.prototype, "logger", void 0);
exports.CommandLoader = CommandLoader;

//# sourceMappingURL=CommandLoader.js.map
