{"version":3,"sources":["util/logger/LoggerDecorator.ts"],"names":[],"mappings":";;AAAA,qCAAkC;AAElC;;;GAGG;AACH,oDAAoD;AAEpD;;;;;;;;;;;;GAYG;AACH,uEAAuE;AACvE,IAAI;AACJ,qDAAqD;AACrD,iCAAiC;AACjC,gCAAgC;AAChC,IAAI;AAEJ;;;;;;;;;;;;;;;GAeG;AACH,gBAA0B,MAAS,EAAE,GAAW;IAE/C,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,GAAG,EAChC,EAAE,KAAK,EAAE,eAAM,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;AAChC,CAAC;AAJD,wBAIC","file":"LoggerDecorator.js","sourcesContent":["import { Logger } from './Logger';\n\n/**\n * Represents a type that has a `logger` property\n * containing the Logger singleton instance\n */\n// export type Loggable<T> = T & { logger: Logger };\n\n/**\n * Class decorator that transforms a class to Loggable<T>.\n * Regrettably works but is not properly picked up by intellisense\n * at this point in time, meaning compiler errors when attempting\n * to access the `logger` property on the decorated class.\n * Maybe someday.\n *\n * Example:\n * ```\n * &#64loggable\n * class Foo { }\n * ```\n */\n// export function loggable<T extends Function>(target: T): Loggable<T>\n// {\n// \tObject.defineProperty(target.prototype, 'logger',\n// \t\t{ value: Logger.instance });\n// \treturn <Loggable<T>> target;\n// }\n\n/**\n * Property decorator that will automatically assign\n * the Logger singleton instance to the decorated\n * class property\n *\n * Example:\n * ```\n * class Foo {\n * \t&#64logger private readonly logger: Logger;\n * \t...\n * ```\n * >**Note:** This is a Typescript feature. If using the logger is desired\n * in Javascript you should simply retrieve the singleton instance via\n * `Logger.instance()`\n * @returns {PropertyDecorator}\n */\nexport function logger<T>(target: T, key: string): void\n{\n\tObject.defineProperty(target, key,\n\t\t{ value: Logger.instance() });\n}\n"],"sourceRoot":"../../../src"}