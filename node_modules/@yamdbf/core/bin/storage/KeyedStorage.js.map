{"version":3,"sources":["storage/KeyedStorage.ts"],"names":[],"mappings":"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","file":"KeyedStorage.js","sourcesContent":["import { StorageProviderConstructor } from '../types/StorageProviderConstructor';\nimport { StorageProvider } from './StorageProvider';\nimport { Util } from '../util/Util';\n\n/**\n * Simple key/value storage abstraction operating on top of the\n * given StorageProvider. Supports nested object paths in\n * get/set/remove using `.` like normal object accessors\n * @param {string} name Unique identifier for this storage, used by the given StorageProvider\n * @param {StorageProviderConstructor} provider The storage provider class that will be instantiated\n * \t\t\t\t\t\t\t\t\t\t\t\tand used as the backend for this storage abstraction\n */\nexport class KeyedStorage\n{\n\tprivate readonly _storage: StorageProvider;\n\tpublic constructor(name: string, provider: StorageProviderConstructor)\n\t{\n\t\tthis._storage = new provider(name);\n\t}\n\n\t/**\n\t * Initialize this storage. Any other method calls should not be made\n\t * until this method has been called and resolved\n\t * @returns {Promise<void>}\n\t */\n\tpublic async init(): Promise<void>\n\t{\n\t\tawait this._storage.init();\n\t}\n\n\t/**\n\t * Get the names of all keys in this storage\n\t * @returns {Promise<string[]>}\n\t */\n\tpublic async keys(): Promise<string[]>\n\t{\n\t\treturn await this._storage.keys();\n\t}\n\n\t/**\n\t * Get a value from this storage for the specified key\n\t * @param {string} key The key in storage to get\n\t * @returns {Promise<any>}\n\t */\n\tpublic async get(key: string): Promise<any>\n\t{\n\t\tif (typeof key === 'undefined') throw new TypeError('Key must be provided');\n\t\tif (typeof key !== 'string') throw new TypeError('Key must be a string');\n\n\t\tif (key.includes('.'))\n\t\t{\n\t\t\tlet path: string[] = key.split('.');\n\t\t\tlet stringData: string = await this._storage.get(path.shift());\n\t\t\tif (typeof stringData === 'undefined') return;\n\t\t\tlet data: object = JSON.parse(stringData);\n\t\t\treturn Util.getNestedValue(data, path);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet stringData: string = await this._storage.get(key);\n\t\t\tif (typeof stringData === 'undefined') return;\n\t\t\treturn JSON.parse(stringData);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a value exists in storage\n\t * @param {string} key The key in storage to check\n\t * @returns {Promise<boolean>}\n\t */\n\tpublic async exists(key: string): Promise<boolean>\n\t{\n\t\treturn typeof await this.get(key) !== 'undefined';\n\t}\n\n\t/**\n\t * Set a value in this storage for the specified key\n\t * @param {string} key The key in storage to set\n\t * @param {any} value The value to set\n\t * @returns {Promise<void>}\n\t */\n\tpublic async set(key: string, value: any): Promise<void>\n\t{\n\t\tif (typeof key === 'undefined') throw new TypeError('Key must be provided');\n\t\tif (typeof key !== 'string') throw new TypeError('Key must be a string');\n\t\tif (typeof value === 'undefined') throw new TypeError('Value must be provided');\n\n\t\ttry { JSON.stringify(value); }\n\t\tcatch (err) { value = {}; }\n\n\t\tlet data: any;\n\t\tif (key.includes('.'))\n\t\t{\n\t\t\tlet path: string[] = key.split('.');\n\t\t\tlet first: string = path.shift();\n\t\t\tdata = await this.get(first);\n\t\t\tif (typeof data === 'undefined')\n\t\t\t\tdata = {};\n\t\t\tUtil.assignNestedValue(data, path, value);\n\t\t\tkey = first;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdata = value;\n\t\t}\n\t\tawait this._storage.set(key, JSON.stringify(data));\n\t}\n\n\t/**\n\t * Remove a key/value pair from this storage\n\t * @param {string} key The key in storage to remove\n\t * @returns {Promise<void>}\n\t */\n\tpublic async remove(key: string): Promise<void>\n\t{\n\t\tif (typeof key === 'undefined') throw new Error('Key must be provided');\n\t\tif (typeof key !== 'string') throw new Error('Key must be a string');\n\n\t\tlet data: any;\n\t\tif (key.includes('.'))\n\t\t{\n\t\t\tlet path: string[] = key.split('.');\n\t\t\tlet first: string = path.shift();\n\t\t\tdata = await this.get(first);\n\t\t\tif (typeof data !== 'undefined')\n\t\t\t\tUtil.removeNestedValue(data, path);\n\n\t\t\tkey = first;\n\t\t\tawait this._storage.set(key, JSON.stringify(data));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tawait this._storage.remove(key);\n\t\t}\n\t}\n\n\t/**\n\t * Remove all key/value pairs from this storage\n\t * @returns {Promise<void>}\n\t */\n\tpublic async clear(): Promise<void>\n\t{\n\t\tawait this._storage.clear();\n\t}\n}\n"],"sourceRoot":"../../src"}