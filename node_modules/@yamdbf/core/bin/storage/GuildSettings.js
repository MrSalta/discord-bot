"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Util_1 = require("../util/Util");
/**
 * Class containing asynchronous methods for storing, retrieving, and
 * interacting with settings for a specific guild. Will be contained
 * under {@link GuildStorage#settings}
 */
class GuildSettings {
    constructor(storage, guild, client) {
        this._provider = storage;
        this._guild = guild;
        this._id = guild.id;
        this._client = client;
        this._cache = {};
    }
    /**
     * Initialize this storage instance
     * @returns {Promise<void>}
     */
    async init(useDefaults = false) {
        try {
            let data = await this._provider.get(this._id);
            if (typeof data === 'undefined') {
                data = {};
                await this._provider.set(this._id, JSON.stringify(data));
            }
            else
                data = JSON.parse(data);
            if (useDefaults) {
                const defaults = await this._client.storage.get('defaultGuildSettings');
                for (const key of Object.keys(defaults))
                    if (typeof data[key] === 'undefined')
                        data[key] = defaults[key];
                await this._provider.set(this._id, JSON.stringify(data));
            }
            this._cache = data;
        }
        catch (err) {
            console.error(err.stack);
        }
    }
    /**
     * Get the names of all keys in this storage for this Guild
     * @returns {Promise<string[]>}
     */
    async keys() {
        return Object.keys(this._cache);
    }
    /**
     * Get a value from storage for this Guild
     * @param {string} key The key in storage to get
     * @returns {Promise<any>}
     */
    async get(key) {
        if (typeof key === 'undefined')
            throw new TypeError('Key must be provided');
        if (typeof key !== 'string')
            throw new TypeError('Key must be a string');
        if (key.includes('.')) {
            let path = key.split('.');
            return Util_1.Util.getNestedValue(this._cache[path.shift()], path);
        }
        else {
            return this._cache[key];
        }
    }
    /**
     * Check if a value exists in storage for this Guild
     * @param {string} key The key in storage to check
     * @returns {Promise<boolean>}
     */
    async exists(key) {
        return typeof await this.get(key) !== 'undefined';
    }
    /**
     * Set a value in storage for this Guild
     * @param {string} key The key in storage to set
     * @param {any} value The value to set
     * @returns {Promise<void>}
     */
    async set(key, value) {
        if (typeof key === 'undefined')
            throw new TypeError('Key must be provided');
        if (typeof key !== 'string')
            throw new TypeError('Key must be a string');
        if (typeof value === 'undefined')
            throw new TypeError('Value must be provided');
        try {
            JSON.stringify(value);
        }
        catch (err) {
            value = {};
        }
        if (key.includes('.')) {
            let path = key.split('.');
            let first = path.shift();
            if (typeof this._cache[first] === 'undefined')
                this._cache[first] = {};
            Util_1.Util.assignNestedValue(this._cache[first], path, value);
        }
        else {
            this._cache[key] = value;
        }
        await this._provider.set(this._id, JSON.stringify(this._cache));
    }
    /**
     * Remove a value from storage for this Guild
     * @param {string} key The key in storage to remove
     * @returns {Promise<void>}
     */
    async remove(key) {
        if (typeof key === 'undefined')
            throw new TypeError('Key must be provided');
        if (typeof key !== 'string')
            throw new TypeError('Key must be a string');
        if (key.includes('.')) {
            let path = key.split('.');
            let first = path.shift();
            if (typeof this._cache[first] !== 'undefined')
                Util_1.Util.removeNestedValue(this._cache[first], path);
        }
        else {
            delete this._cache[key];
        }
        await this._provider.set(this._id, JSON.stringify(this._cache));
    }
    /**
     * Remove all key/value pairs from storage for this Guild
     * @returns {Promise<void>}
     */
    async clear() {
        this._cache = {};
        await this._provider.set(this._id, JSON.stringify(this._cache));
    }
}
exports.GuildSettings = GuildSettings;

//# sourceMappingURL=GuildSettings.js.map
